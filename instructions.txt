Overview: We are going to look at several di erent algorithms to solve a problem, and use
experimental analysis to see which is fastest.

In this lab you will write 4 methods which accept a single int [ ] as an argument, and return an
int. In methods 1 and 3, just use basic for-loops to do the calculations; in methods 2 and 4,
follow the specified algorithm. You will also write a fifth helper method to perform a binary
search.



Part I: Implementing the Algorithms
1. In VSCode, create a new Java project, Lab2FML (replace FML with your first, middle and
last initial), in VS Code, and a package, lab2. All of your classes should be in lab2, except
App.java, which you can leave where it is, in the default package.
2. Implement the 5 methods listed above. To maximize the educational bene ts of this lab, we
will not specify the details of where you should place them, but here are some possibilities:
1. In the App class
2. All the methods together, but in another class
3. Each method in its own class
3. Test your work: write 16 JUnit Jupiter tests to test the following data points.

â€¢ For brevity, there are only 8 rows in the table - but each row requires two tests, one
per method.
MethodsData
Expected Result
nZP(), nZPS(){50, 40, 30, 20, 10}0
nZP(), nZPS(){10, 15, 20, 30, -20, 40, 50}1
nZP(), nZPS(){10, 15, 20, -10, 30, -15}2
nZP(), nZPS(){10, 51, -10, 40, 80,, 94, 17, -80, -40}3


nZT(), nZTS(){10, 20, 30, 40, 50}0
nZT(), nZTS(){41, 11, 69, 5, 308, 425, - 3, 500, -2}1
nZT(), nZTS(){-10, -200, -5, 15, 300, -100, 44, 69}2
nZT(), nZTS(){-2, -300, -200, -3, 500, -30, -20, 50, 5}3


Part II: Timing
Now that we have the methods written, you will investigate how long they take to run. Using
the experimental analysis, we will need to repeatedly
1.Generate random data (ints between -231 and 231 - 1),
2.Record the time
3.Invoke the method, passing in the array
4.Record the time again and subtract to get the elapsed time


and then display the times in one of 4 tables (based on what the user enters in response to a
prompt):
Table 1: nZP() and nZPS(), n = 1000, 2000, ..., 50000 (all values from 1000-50000)
Table 2: nZT() and nZTS(), n = 1000, 1500, ..., 5000 (all values from 1000-5000)
Table 3: nZP() and nZPS(), n = 1000, 2000, 3000, 48000, 49000, 50000 (just these 6)
Table 4: nZT() and nZTS(), n = 1000, 1500, 2000, 4000, 4500, 5000 (just these 6)
The rst two tables will show all possible values of n for their respective methods. The last two
will just display 6 rows (plus a ... row).
The tables should be formatted to look like the sample output (see below). Because of
differences in hardware, your numbers will vary from those shown here.


Visualizing the Results:
1. Generate table 1 (nZP() and nZPS(), n = 1000, 2000, ..., 50000)
2. Copy the output from the terminal into Microsoft Excel
3. Delete the line with the ==============='s
4. Highlight the pasted data (it will all be in column A)
5. Choose Data Split to break the data into columns A, B and C
6. Select columns A, B, and C
7. Under the Insert menu, choose recommended charts
8. Choose an appropriate chart
9. Take a screenshot (which you will upload)
10. Repeat steps 1-9 for table 2 (nZT() and nZTS(), n = 1000, 1500, ..., 5000)