Overview: We are going to look at several di erent algorithms to solve a problem, and use
experimental analysis to see which is fastest.

In this lab you will write 4 methods which accept a single int [ ] as an argument, and return an
int. In methods 1 and 3, just use basic for-loops to do the calculations; in methods 2 and 4,
follow the specified algorithm. You will also write a fifth helper method to perform a binary
search.

1. numZeroPairSums(), aka nZP():
This method returns the number of distinct pairs in an array that sum to 0. For instance, given
the array {10, 3, 18, -10, -3, 4}, numZeroPairSums() would return 2, as there are two pairs (10,
-10) and (3, -3) that sum to 0. Do not double count: pairs (10, -10) and (-10, 10) are the same.
Do not change the array in any way, nor store its values in any other collection. Just use for
loops to process it.

2. numZeroPairSumsSpeedy(), aka nZPS():
This will behave the same as numZeroPairSums(), except, as its name suggests, more speedily.
The algorithm for this method is as follows (where arr represents an int array):
1. Set the number of zero pair sums to 0
2. Sort arr (using Arrays.sort() -- we're in a hurry here!)
3. For the ith element arr[i] (where i = 0, 1, ..., n-1):
1. do a binary search of -arr[i] in arr, and note its index in the array
2. if the index exceeds i, increase the number of zero pair sums // why does this work?

3. numZeroTripletSums(), aka nZT():
This method returns the number of triplets in an array that sum to 0. For instance, given the
array {10, -3, 18, -7, -12, 14, -6}, numZeroTripletSums() would return 2, since (10, -3, -7), and
(18, -12, -6) sum to 0. Do not double count: (10, -3, -7) and (-3, 10, -7) are the same triplet.

4. numZeroTripletSumsSpeedy(), aka nZTS():
This is the speedy analog of numZeroTripletSums(), and the algorithm for this method is as
follows (where arr represents an int array)
1. Set the number of zero triplet sums to 0
2. Sort arr (using Arrays.sort())
3. For the ith element arr[i] (where i = 0, 1, ..., n-1):
1. for the jth element arr[j] (where j = i+1, ..., n-1)
2. do a binary search of -arr[i]-arr[j] in arr, and note its index in the array
3. if that index exceeds j, increase the number of zero triplet sums // why j? why not i?
Hint: try it with the array {40, 60, -100, -3, -3, 6, 400, 800, -1200}

5. binarySearch()
This will take two arguments, an int array and an int key, will return the index of the key if
found, -1 if not. You should be able to write this from scratch, otherwise consult your notes.


Part I: Implementing the Algorithms
1. In VSCode, create a new Java project, Lab2FML (replace FML with your rst, middle and
last initial), in VS Code, and a package, lab2. All of your classes should be in lab2, except
App.java, which you can leave where it is, in the default package.
2. Implement the 5 methods listed above. To maximize the educational bene ts of this lab, we
will not specify the details of where you should place them, but here are some possibilities:
1. In the App class
2. All the methods together, but in another class
3. Each method in its own class
3. Test your work: write 16 JUnit Jupiter tests to test the following data points.

â€¢ For brevity, there are only 8 rows in the table - but each row requires two tests, one
per method.
MethodsData
Expected Result
nZP(), nZPS(){50, 40, 30, 20, 10}0
nZP(), nZPS(){10, 15, 20, 30, -20, 40, 50}1
nZP(), nZPS(){10, 15, 20, -10, 30, -15}2
nZP(), nZPS(){10, 51, -10, 40, 80,, 94, 17, -80, -40}3
nZT(), nZTS(){10, 20, 30, 40, 50}0
nZT(), nZTS(){41, 11, 69, 5, 308, 425, - 3, 500, -2}1
nZT(), nZTS(){-10, -200, -5, 15, 300, -100, 44, 69}2
nZT(), nZTS(){-2, -300, -200, -3, 500, -30, -20, 50, 5}3


Part II: Timing
Now that we have the methods written, you will investigate how long they take to run. Using
the experimental analysis, we will need to repeatedly
1.Generate random data (ints between -231 and 231 - 1),
2.Record the time
3.Invoke the method, passing in the array
4.Record the time again and subtract to get the elapsed time


and then display the times in one of 4 tables (based on what the user enters in response to a
prompt):
Table 1: nZP() and nZPS(), n = 1000, 2000, ..., 50000 (all values from 1000-50000)
Table 2: nZT() and nZTS(), n = 1000, 1500, ..., 5000 (all values from 1000-5000)
Table 3: nZP() and nZPS(), n = 1000, 2000, 3000, 48000, 49000, 50000 (just these 6)
Table 4: nZT() and nZTS(), n = 1000, 1500, 2000, 4000, 4500, 5000 (just these 6)
The rst two tables will show all possible values of n for their respective methods. The last two
will just display 6 rows (plus a ... row).
The tables should be formatted to look like the sample output (see below). Because of
differences in hardware, your numbers will vary from those shown here.


Visualizing the Results:
1. Generate table 1 (nZP() and nZPS(), n = 1000, 2000, ..., 50000)
2. Copy the output from the terminal into Microsoft Excel
3. Delete the line with the ==============='s
4. Highlight the pasted data (it will all be in column A)
5. Choose Data Split to break the data into columns A, B and C
6. Select columns A, B, and C
7. Under the Insert menu, choose recommended charts
8. Choose an appropriate chart
9. Take a screenshot (which you will upload)
10. Repeat steps 1-9 for table 2 (nZT() and nZTS(), n = 1000, 1500, ..., 5000)